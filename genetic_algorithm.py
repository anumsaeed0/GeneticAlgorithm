# -*- coding: utf-8 -*-
"""Genetic Algorithm - Complete Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a0kSgBdluGeTFHNINBYN-lDgnMvFOwqx

# **Genetic Algorithm**
---
 1.  *User input function (No of chromosomes, No of variables [x, y, z], Goal, No of iterations, Acceptable range, Mathematical expression or Function, Max power, Coefficient)*
 2.  *Goal Condition (User input, Sort the list based on the closeness to the goal)*
 3.  *Stopping Criteria (Fixed iterations,  Goal Reached, Error is in acceptable range (Fitness value closer to goal within a certain range), No new Child (Redundant Fitness values))*
 4.  *Crossover and Mutation*

### **Importing random library to generate randomize chromosomes**
"""

import random

"""### **Genetic Algorithm Function**"""

def Gen_Algo(chrs, Goal, Func, vars):
    Fitness = fitness_cal(chrs, Goal, Func, vars)
    return Fitness

"""### **Fitness Calculation Function**

"""

def fitness_cal(chrs, Goal, Func, variables):
    Fitness = {}
    count = 0
    for chr in chrs:
        count += 1
        values = chrs[chr]
        for name, value in zip(variables, values):
            exec(f"{name} = {value}")
        Fitness[f"F{count}"] = [eval(Func)]

    Fitness_sorted = dict(sorted(Fitness.items(), key=lambda item: abs(item[1][0] - Goal)))
    return Fitness_sorted

"""### **Regenerating Chromosomes that are not Fittest by Mutation or Random Method**

"""

def regeneration_by_Mutation(chromosomes, fittest_indices, non_fittest_indices, n_v):
    updated_chromosomes = {}

    for key, value in chromosomes.items():
        if key[1] in non_fittest_indices:
            new_value = []

            for item in range(len(value)):
                random_op = random.choice(['+', '-', '*', '/', "avg"])
                if random_op == "+":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] + Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "-":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] - Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "*":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] * Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "/":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] / Chromosomes[f"C{fittest_indices[1]}"][item]))
                else:
                    new_value.append(int((Chromosomes[f"C{fittest_indices[0]}"][item] + Chromosomes[f"C{fittest_indices[1]}"][item])/2))

            updated_chromosomes[key] = new_value

    return updated_chromosomes

"""### **Regenerating Chromosomes that are not Fittest by Crossing Over the Variable values of Fittest Chromosomes**

"""

def regeneration_by_crossover(chromosomes, fittest_indices, non_fittest_indices, n_v):
    crossover_point = int(n_v/2)

    new_chromosomes = {}

    for key, value in chromosomes.items():
        new_values = []
        if key[1] in fittest_indices:
            new_chromosomes[key] = value
        else:

            while True:
                partner_key1 = random.choice([k for k in chromosomes.keys() if (k[1] in fittest_indices)])
                new_values.extend(chromosomes[partner_key1][:crossover_point])

                partner_key2 = random.choice([k for k in chromosomes.keys() if (k[1] in fittest_indices) and (k[1] != partner_key1[1])])
                new_values.extend(chromosomes[partner_key2][crossover_point:])

                new_key = key[0]+key[1]
                if new_key not in new_chromosomes:
                    break

            new_chromosomes[new_key] = new_values

    return new_chromosomes

"""### **User-defined mathematical expression is generated**

"""

def custom_func(vars):
    expression = ""
    var_list = []
    for i in range(vars+1):
        var = input(f"\n\nEnter the variable {i+1}: ")
        power = int(input(f"Enter power of variable {i+1}: "))
        coeff = int(input(f"Enter coefficient of variable {i+1}: "))

        term = f"{coeff}*({var}**{power})" if power != 0 else str(coeff)

        if power != 0:
          operator = input(f"Enter the operator between variable {i+1} and {i+2}: ")

          expression += term + operator
          var_list.append(var)
        else:
          expression += term

    return expression, var_list

"""## **Main Program**
---

### Initializing/Generating chromosomes on random basis
"""

Chromosomes = dict()

n_c = int(input("Enter No of chromosomes : "))
n_v = int(input("Enter number of variables for each chromosome : "))

# Generating Chromosomes on Random basis
for item in range(n_c):
    Chromosomes[f"C{item+1}"] = []
    for item_sub in range(n_v):
        a=int(random.randint(-10, 10))
        Chromosomes[f"C{item+1}"].append(a)

"""### Initial Chromosomes"""

print("\nInitial Chromosomes:", Chromosomes, end="\n\n")

"""### Declaration of Variables"""

Fitness_Record = {}

count = 0

"""### Input Objective/Fitness Function"""

# User Input functions
Goal = int(input("Enter the Goal: "))
No_of_iter = int(input("Enter the No. of Iterations: "))
closeness = int(input("Enter the Range Value for closeness: "))

# Returns the mathematical expressiona and variables
Func, vars = custom_func(n_v)

print(f"Fitness or Objective Function : {Func}")
# example expression
# { -3*((x)**3))+7*((y)**2)+15 }

print(vars)

"""### Running Genetic Algorithm and for regeneration crossing over and mutation is used"""

# loop that stops when no of iterations complete
while count != No_of_iter:
    Fitness = Gen_Algo(Chromosomes, Goal, Func, vars)

    print("Fitness Values : ", Fitness)

    print("Fitness Record : ", Fitness_Record, end= "\n\n")

    if Goal in Fitness.values():
        print("\nReached the goal.")
        break

    elif any((Goal - closeness) <= list(Fitness.values())[0][0] <= (Goal + closeness) for value in Fitness.values()):
        print("\nNearer to the goal.")
        break

    elif any(value[0] in [record_value[0] for record_value in Fitness_Record.values()] for value in Fitness.values()):
        print("\nThe Fitness values are redundant.")
        break

    else:
        alpha = []

        for each in Fitness:
            alpha.append(each[1])

        out = len(Chromosomes)
        avg = int(out/2)
        not_fit = alpha[avg:]
        fit_index = alpha[:avg]

        # Regeneration by both methods MUTATION & CROSSING OVER

        # new_chromosomes = regeneration_by_Mutation(Chromosomes, fit_index, not_fit, n_v)
        new_chromosomes = regeneration_by_crossover(Chromosomes, fit_index, not_fit, n_v)

        Chromosomes.update(new_chromosomes)

        print("After Regeneration:", Chromosomes, end= "\n\n")

    if len(Fitness_Record) == 0:
        Fitness_Record = Fitness
    else:
        cnt = 0
        for key, value in Fitness.items():
            cnt += 1
            Fitness_Record[f"F{cnt}"].extend(value)

        count += 1
else:
    print("\nGoal not reached.")

import random

# Genetic Algorithm Function
def Gen_Algo(chrs, Goal, Func, vars):
    Fitness = fitness_cal(chrs, Goal, Func, vars)
    return Fitness

# Fitness Calculation Function
def fitness_cal(chrs, Goal, Func, variables):
    Fitness = {}
    count = 0
    for chr in chrs:
        count += 1
        values = chrs[chr]
        for name, value in zip(variables, values):
            exec(f"{name} = {value}")
        Fitness[f"F{count}"] = [eval(Func)]

    Fitness_sorted = dict(sorted(Fitness.items(), key=lambda item: abs(item[1][0] - Goal)))
    return Fitness_sorted

# Regenerating Chromosomes that are not Fittest by Mutation or Random Method
def regeneration_by_Mutation(chromosomes, fittest_indices, non_fittest_indices, n_v):
    updated_chromosomes = {}

    for key, value in chromosomes.items():
        if key[1] in non_fittest_indices:
            new_value = []

            for item in range(len(value)):
                random_op = random.choice(['+', '-', '*', '/', "avg"])
                if random_op == "+":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] + Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "-":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] - Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "*":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] * Chromosomes[f"C{fittest_indices[1]}"][item]))
                elif random_op == "/":
                    new_value.append(int(Chromosomes[f"C{fittest_indices[0]}"][item] / Chromosomes[f"C{fittest_indices[1]}"][item]))
                else:
                    new_value.append(int((Chromosomes[f"C{fittest_indices[0]}"][item] + Chromosomes[f"C{fittest_indices[1]}"][item])/2))

            updated_chromosomes[key] = new_value

    return updated_chromosomes

# Regenerating Chromosomes that are not Fittest by Crossing Over the Variable values of Fittest Chromosomes
def regeneration_by_crossover(chromosomes, fittest_indices, non_fittest_indices, n_v):
    crossover_point = int(n_v/2)

    new_chromosomes = {}

    for key, value in chromosomes.items():
        new_values = []
        if key[1] in fittest_indices:
            new_chromosomes[key] = value
        else:

            while True:
                partner_key1 = random.choice([k for k in chromosomes.keys() if (k[1] in fittest_indices)])
                new_values.extend(chromosomes[partner_key1][:crossover_point])

                partner_key2 = random.choice([k for k in chromosomes.keys() if (k[1] in fittest_indices) and (k[1] != partner_key1[1])])
                new_values.extend(chromosomes[partner_key2][crossover_point:])

                new_key = key[0]+key[1]
                if new_key not in new_chromosomes:
                    break

            new_chromosomes[new_key] = new_values

    return new_chromosomes

# User-defined mathematical expression
def custom_func(vars):
    expression = ""
    var_list = []
    for i in range(vars+1):
        var = input(f"\n\nEnter the variable {i+1}: ")
        power = int(input(f"Enter power of variable {i+1}: "))
        coeff = int(input(f"Enter coefficient of variable {i+1}: "))
        operator = input(f"Enter the operator between variable {i+1} and {i+2}: ")

        term = f"{coeff}*({var}**{power})" if power != 0 else str(coeff)
        expression += term + operator

        if power != 0:
          var_list.append(var)

    return expression, var_list

# Main Program
Chromosomes = dict()

n_c = int(input("Enter No of chromosomes : "))
n_v = int(input("Enter number of variables for each chromosome : "))

# Generating Chromosomes on Random basis
for item in range(n_c):
    Chromosomes[f"C{item+1}"] = []
    for item_sub in range(n_v):
        a=int(random.randint(-10, 10))
        Chromosomes[f"C{item+1}"].append(a)

print("\nInitial Chromosomes:", Chromosomes, end="\n\n")

# User Input functions
Goal = int(input("Enter the Goal: "))
No_of_iter = int(input("Enter the No. of Iterations: "))
closeness = int(input("Enter the Range Value for closeness: "))

Fitness_Record = {}

count = 0

# Returns the mathematical expressiona and variables
Func, vars = custom_func(n_v)

# loop that stops when no of iterations complete
while count != No_of_iter:
    Fitness = Gen_Algo(Chromosomes, Goal, Func, vars)

    print("Fitness Values : ", Fitness)

    print("Fitness Record : ", Fitness_Record, end= "\n\n")

    if Goal in Fitness.values():
        print("\nReached the goal.")
        break

    elif any((Goal - closeness) <= list(Fitness.values())[0][0] <= (Goal + closeness) for value in Fitness.values()):
        print("\nNearer to the goal.")
        break

    elif any(value[0] in [record_value[0] for record_value in Fitness_Record.values()] for value in Fitness.values()):
        print("\nThe Fitness values are redundant.")
        break

    else:
        alpha = []

        for each in Fitness:
            alpha.append(each[1])

        out = len(Chromosomes)
        avg = int(out/2)
        not_fit = alpha[avg:]
        fit_index = alpha[:avg]

        # Regeneration by both metjods MUTATION & CROSSING OVER

        # new_chromosomes = regeneration_by_Mutation(Chromosomes, fit_index, not_fit, n_v)
        new_chromosomes = regeneration_by_crossover(Chromosomes, fit_index, not_fit, n_v)

        Chromosomes.update(new_chromosomes)

        print("After Regeneration:", Chromosomes, end= "\n\n")

    if len(Fitness_Record) == 0:
        Fitness_Record = Fitness
    else:
        cnt = 0
        for key, value in Fitness.items():
            cnt += 1
            Fitness_Record[f"F{cnt}"].extend(value)

        count += 1
else:
    print("\nGoal not reached.")


# example expression
# { -3*((x)**3))+7*((y)**2)+15 }